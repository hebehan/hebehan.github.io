[{"categories":null,"content":"1.埋点 有哪些方式 原理 1.AOP:面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术 AspectJ 在编译时候,动态对 class 文件进行修改 主要实现方式是动态代理 InvocationHandler 2.lifecycle 原理,利用 fragment 感知 activity 生命周期 fragment 拿到 LifecycleObserver 对象,然后再不同的生命周期回调 2.Tinker 热更新原理 1.保留第一次打包的 APK 以及 mapping 文件 2.第二次打包时候,跟原 apk 进行 diff 3.将变更的代码做成apk包 4.下发的时候将补丁包内的dex放到dex队列最前面 由于Tinker的方案是基于Multidex实现的修改dexElements的顺序实现的，所以最终还是要修改classLoder中dexPathList中dexElements的顺序。Android中有两种ClassLoader用于加载dex文件，BootClassLoader、PathClassLoader和DexClassLoader都是继承自BaseDexClassLoader 3 Retrifit2 涉及到的设计模式 外观模式，构建者模式，工厂模式，代理模式，适配器模式，策略模式，观察者模式 App应用程序通过Retrofit请求网络，实际上是使用Retrofit接口层封装请求参数，之后由OkHttp完成后续的请求操作。 在服务端返回数据之后，OkHttp将原始的结果交给Retrofit，Retrofit根据用户的需求对结果进行解析。 完成数据的转化(converterFactory)，适配(callAdapterFactory)，通过设计模式进行各种扩展。 使用Retrofit的七步骤 添加Retrofit依赖，网络权限 定义接收服务器返回数据的Bean 创建网络请求的接口，使用注解(动态代理，核心) builder模式创建Retrofit实例，converter，calladapter... 创建接口实例，调用具体的网络请求 call同步/异步网络请求 处理服务器返回的数据 Retrofit网络通信八步骤 创建Retrofit实例 定义网络请求接口，并为接口中的方法添加注解 通过动态代理生成网络请求对象 通过网络请求适配器将网络请求对象进行平台适配 通过网络请求执行器，发送网络请求(call) 通过数据解析器解析数据 通过回调执行器，切换线程 用户在主线程处理返回结果 ","date":"2020-11-04","objectID":"/jianlizhishidian/:0:0","tags":null,"title":"简历知识点","uri":"/jianlizhishidian/"},{"categories":null,"content":" 自我介绍 突出亮点 您好,我叫韩超杰,我目前就职于达达京东到家,在武汉上大学,学的是软件工程专业,在工作中我比较较真,会主动思考如何能用简洁的代码解决问题,同时我是一个有一些特别想法的人,并且我一定会把它实现出来,比如我拿一等奖的一键发单,比如用语音帮助公司定会议室,用程序将一些事情化繁为简 为什么离职 在达达呆了快 4 年了,觉得自己的已经开始有一些安于现状了,因此想出去了解一下机会,如果有合适的机会,可以换个环境 下个工作的期望 下个工作,首先最好能做一些自己之前没做过的,再一个就是项目能提高自己能力的,无论是从设计方面还是代码方面,同时,也希望新公司能有一些技术氛围,大家互相讨论,进步会更快 学习能力 1.梳理技术栈 一些 google 的新技术现在项目没有用,如 databinding kotlin 项目中用的比较少,还有待提高 由于之前做内部工具比较多,因此在大用户量的 app 上的经验待提高 2.困难克服 做一键发单的时候,遇到浏览器内核不能完美兼容,因此换了很多个内核,最后通过修改替换 js 的方法解决问题,成就感特别强 3.经验教训 不要过度封装,方法不需要重载过多 在做一些不明确的操作的时候,多加判断,能显著降低 app 的崩溃 ","date":"2020-11-04","objectID":"/202011fighting/:0:0","tags":null,"title":"202011fighting","uri":"/202011fighting/"},{"categories":null,"content":" //如果再抽象类内使用,只能拿到抽象类的类名,不能拿到继承抽象类,然后调用静态方法的类名 //方案1 10万次 30ms private static final Class getCurrentClass(){ return new Object(){ public Class getClassForStatic(){ return this.getClass(); } }.getClassForStatic(); } //方案2 null exception 风险 10万次 220ms private static final String getCurrentClass1(){ return new SecurityManager(){ public String getClassName(){ return getClassContext()[1].getName(); } }.getClassName(); } //方案3 10万次 955ms private static final String getCurrentClass2(){ return new Throwable().getStackTrace()[1].getClassName(); } //方案4 10万次 30ms private static final String getCurrentClass3(){ return new Object(){ public String getClassName(){ return this.getClass().getName().substring(0, this.getClass().getName().lastIndexOf('$')); } }.getClassName(); } ","date":"2020-10-14","objectID":"/getclassfromstaticmethod/:0:0","tags":null,"title":"Getclassfromstaticmethod","uri":"/getclassfromstaticmethod/"},{"categories":null,"content":"1 开场自我介绍 有没有什么擅长的技术方面 java aop 原理 动态代理 埋点时 list item 怎么处理 埋点数据存储,上传 fragment 之间交互 classloader 什么时候卸载 java class dex 文件有什么区别 new thread 会导致内存泄漏吗? 持有外部引用吗 threadlocal 介绍一下,会造成内存泄漏么 耗电量的优化 service 在后台有什么影响(问题) 算法: 层序遍历 ","date":"2020-09-27","objectID":"/bytedance1/:0:0","tags":null,"title":"字节一面总结","uri":"/bytedance1/"},{"categories":null,"content":"计算机网络 TCP UDP 区别 都是传输协议 TCP/IP Transmission Control Protocol / Internet Protocol TCP/IP互联网各类协议总称 TCP UDP IP FTP HTTP ICMP SMTP等 协议如图 OSI七层模型 应用层 表示层 会话层 传输层 网络层 数据链路层 物理层 UPD(User Datagram Protocol) UDP协议全称是用户数据报协议，在网络中它与TCP协议一样用于处理数据包，是一种无连接的协议 特点 1.面向无连接 不进行三次握手 只有协议+内容 不对报文拆分拼接 2.有单播,多播,广播 一对一 一对多 多对多 多对一 3.面向报文 自己选择报文大小 4.不可靠 体现在无连接上 5.传输头部小,速度更高效 TCP 为什么比 UDP 稳定 1.TCP链接前3次握手,并且会确认是否送达 2.UDP是无链接,不管数据是否送达,都会继续发送 3.tcp协议在确认客户端接收到完整的信息之后才会删除服务端操作系统中的缓存，否则就会继续发 三次握手 四次挥手 （1）序号（sequence number）：Seq序号，占32位，用来标识从TCP源端向目的端发送的字节流，发起方发送数据时对此进行标记。 （2）确认号（acknowledgement number）：Ack序号，占32位，只有ACK标志位为1时，确认序号字段才有效，Ack=Seq+1。 （3）标志位（Flags）：共6个，即URG、ACK、PSH、RST、SYN、FIN等。具体含义如下： URG：紧急指针（urgent pointer）有效。 ACK：确认序号有效。 PSH：接收方应该尽快将这个报文交给应用层。 RST：重置连接。 SYN：发起一个新连接。 FIN：释放一个连接。 需要注意的是： 不要将确认序号Ack与标志位中的ACK搞混了。确认方Ack=发起方Seq+1，两端配对。 第一次握手 客户端向服务端发送连接请求报文段。该报文段中包含自身的数据通讯初始序号。请求发送后，客户端便进入 SYN-SENT 状态。 第二次握手 服务端收到连接请求报文段后，如果同意连接，则会发送一个应答，该应答中也会包含自身的数据通讯初始序号，发送完成后便进入 SYN-RECEIVED 状态。 第三次握手 当客户端收到连接同意的应答后，还要向服务端发送一个确认报文。客户端发完这个报文段后便进入 ESTABLISHED 状态，服务端收到这个应答后也进入 ESTABLISHED 状态，此时连接建立成功。 这里可能大家会有个疑惑：为什么 TCP 建立连接需要三次握手，而不是两次？这是因为这是为了防止出现失效的连接请求报文段被服务端接收的情况，从而产生错误。 为什么要进行第三次握手 为了防止服务器端开启一些无用的连接增加服务器开销以及防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。 为什么“握手”是三次，“挥手”却要四次？ TCP建立连接时之所以只需要\"三次握手\"，是因为在第二次\"握手\"过程中，服务器端发送给客户端的TCP报文是以SYN与ACK作为标志位的。SYN是请求连接标志，表示服务器端同意建立连接；ACK是确认报文，表示告诉客户端，服务器端收到了它的请求报文。 即SYN建立连接报文与ACK确认接收报文是在同一次\"握手\"当中传输的，所以\"三次握手\"不多也不少，正好让双方明确彼此信息互通。 为什么客户端在TIME-WAIT阶段要等2MSL? 为的是确认服务器端是否收到客户端发出的ACK确认报文 当客户端发出最后的ACK确认报文时，并不能确定服务器端能够收到该段报文。所以客户端在发送完ACK确认报文之后，会设置一个时长为2MSL的计时器。MSL指的是Maximum Segment Lifetime：一段TCP报文在传输过程中的最大生命周期。2MSL即是服务器端发出为FIN报文和客户端发出的ACK确认报文所能保持有效的最大时长。 服务器端在1MSL内没有收到客户端发出的ACK确认报文，就会再次向客户端发出FIN报文； 如果客户端在2MSL内，再次收到了来自服务器端的FIN报文，说明服务器端由于各种原因没有接收到客户端发出的ACK确认报文。客户端再次向服务器端发出ACK确认报文，计时器重置，重新开始2MSL的计时； 否则客户端在2MSL内没有再次收到来自服务器端的FIN报文，说明服务器端正常接收了ACK确认报文，客户端可以进入CLOSED阶段，完成“四次挥手”。 所以，客户端要经历时长为2SML的TIME-WAIT阶段；这也是为什么客户端比服务器端晚进入CLOSED阶段的原因 挥手之前主动释放连接的客户端结束ESTABLISHED阶段。随后开始“四次挥手”： （1）首先客户端想要释放连接，向服务器端发送一段TCP报文，其中： 标记位为FIN，表示“请求释放连接“； 序号为Seq=U； 随后客户端进入FIN-WAIT-1阶段，即半关闭阶段。并且停止在客户端到服务器端方向上发送数据，但是客户端仍然能接收从服务器端传输过来的数据。 注意：这里不发送的是正常连接时传输的数据(非确认报文)，而不是一切数据，所以客户端仍然能发送ACK确认报文。 （2）服务器端接收到从客户端发出的TCP报文之后，确认了客户端想要释放连接，随后服务器端结束ESTABLISHED阶段，进入CLOSE-WAIT阶段（半关闭状态）并返回一段TCP报文，其中： 标记位为ACK，表示“接收到客户端发送的释放连接的请求”； 序号为Seq=V； 确认号为Ack=U+1，表示是在收到客户端报文的基础上，将其序号Seq值加1作为本段报文确认号Ack的值； 随后服务器端开始准备释放服务器端到客户端方向上的连接。 客户端收到从服务器端发出的TCP报文之后，确认了服务器收到了客户端发出的释放连接请求，随后客户端结束FIN-WAIT-1阶段，进入FIN-WAIT-2阶段 前\"两次挥手\"既让服务器端知道了客户端想要释放连接，也让客户端知道了服务器端了解了自己想要释放连接的请求。于是，可以确认关闭客户端到服务器端方向上的连接了 （3）服务器端自从发出ACK确认报文之后，经过CLOSED-WAIT阶段，做好了释放服务器端到客户端方向上的连接准备，再次向客户端发出一段TCP报文，其中： 标记位为FIN，ACK，表示“已经准备好释放连接了”。注意：这里的ACK并不是确认收到服务器端报文的确认报文。 序号为Seq=W； 确认号为Ack=U+1；表示是在收到客户端报文的基础上，将其序号Seq值加1作为本段报文确认号Ack的值。 随后服务器端结束CLOSE-WAIT阶段，进入LAST-ACK阶段。并且停止在服务器端到客户端的方向上发送数据，但是服务器端仍然能够接收从客户端传输过来的数据。 （4）客户端收到从服务器端发出的TCP报文，确认了服务器端已做好释放连接的准备，结束FIN-WAIT-2阶段，进入TIME-WAIT阶段，并向服务器端发送一段报文，其中： 标记位为ACK，表示“接收到服务器准备好释放连接的信号”。 序号为Seq=U+1；表示是在收到了服务器端报文的基础上，将其确认号Ack值作为本段报文序号的值。 确认号为Ack=W+1；表示是在收到了服务器端报文的基础上，将其序号Seq值作为本段报文确认号的值。 随后客户端开始在TIME-WAIT阶段等待2MSL 为什么要客户端要等待2MSL呢？见后文。 服务器端收到从客户端发出的TCP报文之后结束LAST-ACK阶段，进入CLOSED阶段。由此正式确认关闭服务器端到客户端方向上的连接。 客户端等待完2MSL之后，结束TIME-WAIT阶段，进入CLOSED阶段，由此完成“四次挥手”。 后“两次挥手”既让客户端知道了服务器端准备好释放连接了，也让服务器端知道了客户端了解了自己准备好释放连接了。于是，可以确认关闭服务器端到客户端方向上的连接了，由此完成“四次挥手”。 与“三次挥手”一样，在客户端与服务器端传输的TCP报文中，双方的确认号Ack和序号Seq的值，都是在彼此Ack和Seq值的基础上进行计算的，这样做保证了TCP报文传输的连贯性，一旦出现某一方发出的TCP报文丢失，便无法继续\"挥手\"，以此确保了\"四次挥手\"的顺利完成。 http https 区别 加密过程 HTTPS和HTTP的区别主要如下： 1、https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。 2、http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。 3、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。 4、http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认 证的网络协议，比http协议安全。 http 请求头部 断点重传 cache 请求头用range Range:(unit=first byte pos)-[last byte pos] Range: bytes=0-499 表示第 0-499 字节范围的内容 Range: bytes=500-999 表示第 500-999 字节范围的内容 Range: bytes=-500 表示最后 500 字节的内容 Range: bytes=500- 表示从第 500 字节开始到文件结束部分的内容 Range: bytes=0-0,-1 表示第一个和最后一个字节 Range: bytes=500-600,601-999 同时指定几个范围 请求结果用下面的 200换206 Content-Ran","date":"2020-09-10","objectID":"/interview_qa/:0:1","tags":null,"title":"Interview_qa","uri":"/interview_qa/"},{"categories":["Android"],"content":"概述 ","date":"2020-09-08","objectID":"/android_message/:0:0","tags":["Android","handler","message"],"title":"Android消息机制","uri":"/android_message/"},{"categories":["Android"],"content":"本质:一个线程开启循环模式持续监听并依次处理其他线程给它发送的消息 ","date":"2020-09-08","objectID":"/android_message/:0:1","tags":["Android","handler","message"],"title":"Android消息机制","uri":"/android_message/"},{"categories":["mysql"],"content":"登录 mysql -u root -p密码(不推荐) mysql -u root -p回车后输入密码 ","date":"2020-06-19","objectID":"/mysqlcommand/:1:0","tags":["mysql","常用命令"],"title":"Mysql 常用命令","uri":"/mysqlcommand/"},{"categories":["mysql"],"content":"数据库相关 ","date":"2020-06-19","objectID":"/mysqlcommand/:2:0","tags":["mysql","常用命令"],"title":"Mysql 常用命令","uri":"/mysqlcommand/"},{"categories":["mysql"],"content":"创建数据库 create database 数据库名称; ","date":"2020-06-19","objectID":"/mysqlcommand/:2:1","tags":["mysql","常用命令"],"title":"Mysql 常用命令","uri":"/mysqlcommand/"},{"categories":["mysql"],"content":"显示现有数据库 show databases; ","date":"2020-06-19","objectID":"/mysqlcommand/:2:2","tags":["mysql","常用命令"],"title":"Mysql 常用命令","uri":"/mysqlcommand/"},{"categories":["mysql"],"content":"显示建库语句 show create database 数据库名称; ","date":"2020-06-19","objectID":"/mysqlcommand/:2:3","tags":["mysql","常用命令"],"title":"Mysql 常用命令","uri":"/mysqlcommand/"},{"categories":["mysql"],"content":"使用某个数据库 use 数据库名称; ","date":"2020-06-19","objectID":"/mysqlcommand/:2:4","tags":["mysql","常用命令"],"title":"Mysql 常用命令","uri":"/mysqlcommand/"},{"categories":["mysql"],"content":"删除某个数据库 drop database 数据库名称; ","date":"2020-06-19","objectID":"/mysqlcommand/:2:5","tags":["mysql","常用命令"],"title":"Mysql 常用命令","uri":"/mysqlcommand/"},{"categories":["mysql"],"content":"常用操作 ","date":"2020-06-19","objectID":"/mysqlcommand/:3:0","tags":["mysql","常用命令"],"title":"Mysql 常用命令","uri":"/mysqlcommand/"},{"categories":["mysql"],"content":"显示建表语句 show create table 表名; ","date":"2020-06-19","objectID":"/mysqlcommand/:3:1","tags":["mysql","常用命令"],"title":"Mysql 常用命令","uri":"/mysqlcommand/"},{"categories":["mysql"],"content":"添加字段 ALTER TABLE 表名 ADD 字段名1 类型名(长度) NOT NULL DEFAULT '' COMMENT '备注1', ADD 字段名2 类型名(长度) NOT NULL DEFAULT '' COMMENT '备注2'; ","date":"2020-06-19","objectID":"/mysqlcommand/:3:2","tags":["mysql","常用命令"],"title":"Mysql 常用命令","uri":"/mysqlcommand/"},{"categories":["mysql"],"content":"修改字段 alter table 表名 modify 字段名1 类型名(长度) NOT NULL DEFAULT '' COMMENT '备注1', modify 字段名2 类型名(长度) NOT NULL DEFAULT '' COMMENT '备注2'; ","date":"2020-06-19","objectID":"/mysqlcommand/:3:3","tags":["mysql","常用命令"],"title":"Mysql 常用命令","uri":"/mysqlcommand/"},{"categories":["mysql"],"content":"移动字段顺序 1.跟在某字段后面 alter table 表名 modify 字段名 类型名(长度) NOT NULL DEFAULT '' COMMENT '备注' after 跟着的字段(排在谁后面) 2.直接到首位 alter table 表名 modify 字段名 类型名(长度) NOT NULL DEFAULT '' COMMENT '备注' first ","date":"2020-06-19","objectID":"/mysqlcommand/:3:4","tags":["mysql","常用命令"],"title":"Mysql 常用命令","uri":"/mysqlcommand/"},{"categories":["mysql"],"content":"删除字段 alter table 表名 drop column 字段名1,drop column 字段名2; ","date":"2020-06-19","objectID":"/mysqlcommand/:3:5","tags":["mysql","常用命令"],"title":"Mysql 常用命令","uri":"/mysqlcommand/"},{"categories":["mysql"],"content":"添加索引 ALTER TABLE `表名` ADD INDEX 索引名1 ( `字段名`), ADD INDEX 索引名2 ( `字段名1`,`字段名2`), ADD INDEX 索引名3 ( `字段名`); ","date":"2020-06-19","objectID":"/mysqlcommand/:3:6","tags":["mysql","常用命令"],"title":"Mysql 常用命令","uri":"/mysqlcommand/"},{"categories":["mysql"],"content":"删除索引 alter table 表名 drop index 索引名1,drop index 索引名2; 删除主键 谨慎操作 alter table 表名 drop primary key; ","date":"2020-06-19","objectID":"/mysqlcommand/:3:7","tags":["mysql","常用命令"],"title":"Mysql 常用命令","uri":"/mysqlcommand/"},{"categories":["mysql"],"content":"修改索引 mysql 修改索引需要先删除索引再增加索引 ","date":"2020-06-19","objectID":"/mysqlcommand/:3:8","tags":["mysql","常用命令"],"title":"Mysql 常用命令","uri":"/mysqlcommand/"},{"categories":["mysql"],"content":"重置自增值 alter table 表名 auto_increment = 1; ","date":"2020-06-19","objectID":"/mysqlcommand/:3:9","tags":["mysql","常用命令"],"title":"Mysql 常用命令","uri":"/mysqlcommand/"},{"categories":["杂谈"],"content":"新建文章 hugo new 路由名/文章名 hugo new posts/xxx.md ","date":"2020-05-22","objectID":"/hugocommand/:1:0","tags":["first","hugo","常用命令"],"title":"Hugo常用命令","uri":"/hugocommand/"},{"categories":["杂谈"],"content":"生成网站 hugo ","date":"2020-05-22","objectID":"/hugocommand/:2:0","tags":["first","hugo","常用命令"],"title":"Hugo常用命令","uri":"/hugocommand/"},{"categories":["杂谈"],"content":"本地运行 hugo server ","date":"2020-05-22","objectID":"/hugocommand/:3:0","tags":["first","hugo","常用命令"],"title":"Hugo常用命令","uri":"/hugocommand/"},{"categories":["杂谈"],"content":"主题教程地址 Love It 主题地址 Love It github 地址 ","date":"2020-05-22","objectID":"/hugocommand/:4:0","tags":["first","hugo","常用命令"],"title":"Hugo常用命令","uri":"/hugocommand/"}]